local Library = loadstring(game:HttpGetAsync("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/SaveManager.luau"))()
local InterfaceManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()
--local MarketplaceService = game:GetService("MarketplaceService")
--local gamename = MarketplaceService:GetProductInfo(game.PlaceId).Name


local Window = Library:CreateWindow({
    Title = "Apel Hub",
    SubTitle = tostring("Bubble Gum Simulator Infinity"),
    TabWidth = 160,
    Size = UDim2.fromOffset(900, 600),
    Acrylic = false, -- The blur may be detectable, setting this to false disables blur entirely
    Resize = true, -- Resize this ^ Size according to a 1920x1080 screen, good for mobile users but may look weird on some devices
    MinSize = Vector2.new(250, 250),
    Acrylic = false, -- The blur may be detectable, setting this to false disables blur entirely
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
})

local Tabs = {
    Credits = Window:CreateTab({Title = "Credits", Icon = "book"}),
    Farm = Window:CreateTab({ Title = "Farming", Icon = "align-center" }),
    Enchants = Window:CreateTab({Title = "Auto Enchants", Icon = "book"}),
    Teleport = Window:CreateTab({Title = "Teleport", Icon = "users"}),
    Eggs = Window:CreateTab({Title = "Eggs", Icon = "egg"}),
    Chests = Window:CreateTab({Title = "Chests", Icon = "box"}),
    AutoBuy = Window:CreateTab({Title = "Auto Buy", Icon = "shopping-cart"}),
    AutoDelete = Window:CreateTab({Title = "Auto Delete", Icon = "trash"}),
    AutoUse = Window:CreateTab({Title = "Auto Use", Icon = "pill-bottle"}),
    Misc = Window:CreateTab({Title = " Misc", Icon = "diamond"}),
    Settings = Window:CreateTab({ Title = "Settings", Icon = "settings" }),

}

Tabs.Credits:CreateParagraph("Aligned Paragraph", {
    Title = "Discord",
    Content = "https://discord.gg/4gDAbj2VXG\n Dev - Apelsinka",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Center
})

Tabs.Credits:CreateButton({
    Title = "Copy Discord link",
    Description = "Click it",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Center,
    Callback = function()
        local link = "https://discord.gg/4gDAbj2VXG"
        setclipboard(link)
    end
})


local Options = Library.Options
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character
local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local bb=game:service'VirtualUser'
    game:service'Players'.LocalPlayer.Idled:connect(function()
    bb:CaptureController()bb:ClickButton2(Vector2.new())end)

folderName = "Apel Hub"
PositionfileName = "Saved Position3.txt"
PositionfolderPath = folderName .. "\\" .. PositionfileName

-- Проверяем, существует ли папка
if not isfolder(folderName) then
    makefolder(folderName)  -- Создаем папку, если она не существует
    print("Папка '" .. folderName .. "' была создана.")
else
    print("Папка '" .. folderName .. "' уже существует.")
end

-- Проверяем, существует ли файл
if not isfile(PositionfolderPath) then
    local positionforsave = "41.17556381225586, 9.19631576538086, -42.34333419799805"
    if not isfile(PositionfolderPath) then
        writefile(PositionfolderPath, tostring(positionforsave))
    end

    print("Файл '" .. PositionfileName.." был создан и записан.")
else
    print("Файл '" .. PositionfileName.." был создан и записан.")
end

coroutine.wrap(function()
    local GC = getconnections or get_signal_cons
	if GC then
		for i,v in pairs(GC(game:GetService("Players").LocalPlayer.Idled)) do
			if v["Disable"] then
				v["Disable"](v)
			elseif v["Disconnect"] then
				v["Disconnect"](v)
			end
		end
	else
		local VirtualUser = cloneref(game:GetService("VirtualUser"))
		game:GetService("Players").LocalPlayer.Idled:Connect(function()
			VirtualUser:CaptureController()
			VirtualUser:ClickButton2(Vector2.new())
		end)
	end
end)()

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local player = Players.LocalPlayer


local function updatePetsFolder()
    local success, LocalData = pcall(function()
        return require(ReplicatedStorage.Client.Framework.Services.LocalData)
    end)

    if not success then
        return
    end

    local petsFolder = player:FindFirstChild("Pets")
    if not petsFolder then
        petsFolder = Instance.new("Folder")
        petsFolder.Name = "Pets"
        petsFolder.Parent = player
    end

    local Data = LocalData:Get()

    local petsData = Data.Pets

    if type(petsData) == "table" then
        for i, v in pairs(petsData) do
            local petId = v["Id"]
            local petEnchants = v["Enchants"]
            local petName = v["Name"]
            local Shiny = tostring(v["Shiny"])
            local petFolder = petsFolder:FindFirstChild(tostring(petId))
            if not petFolder then
                petFolder = Instance.new("Folder")
                petFolder.Name = tostring(petId)
                petFolder.Parent = petsFolder
            end

            local ValueOfPetName = petFolder:GetAttribute("Name")
            if ValueOfPetName == nil or ValueOfPetName ~= petName then
                petFolder:SetAttribute("Name", petName)
            end
            local EnchantsFolder = petFolder:FindFirstChild("Enchants")
            if not EnchantsFolder then
                EnchantsFolder = Instance.new("Folder")
                EnchantsFolder.Name = "Enchants"
                EnchantsFolder.Parent = petFolder
            end
            if Shiny == "true" then
                for k = 1, 2 do
                    local enchantFolder = EnchantsFolder:FindFirstChild(tostring(k))
                    if not enchantFolder then
                        enchantFolder = Instance.new("Folder")
                        enchantFolder.Name = tostring(k)
                        enchantFolder.Parent = EnchantsFolder
                    end
                end
            else
                local enchantFolder = EnchantsFolder:FindFirstChild("1")
                if not enchantFolder then
                    enchantFolder = Instance.new("Folder")
                    enchantFolder.Name = tostring("1")
                    enchantFolder.Parent = EnchantsFolder
                end
            end

            if petEnchants ~= nil then
                for o, p in pairs(petEnchants) do
                    local enchantFolder = EnchantsFolder:FindFirstChild(tostring(o))

                    local rnValueofIdEnchant = p["Id"]
                    local rnValueOfLevelEnchant = p["Level"]
                    local ValueOfIdEnchant = enchantFolder:GetAttribute("Id")
                    local ValueOfLevelEnchant = enchantFolder:GetAttribute("Level")

                    if ValueOfLevelEnchant == nil or ValueOfIdEnchant ~= rnValueofIdEnchant or ValueOfLevelEnchant == nil  or ValueOfLevelEnchant ~= rnValueOfLevelEnchant then
                        enchantFolder:SetAttribute("Enchant", tostring(rnValueofIdEnchant).." "..tostring(rnValueOfLevelEnchant))
                    end
                end
            end
        end
    end


    local currentUnitIds = {} 
    for i, v in pairs(petsData) do
        local petId = v["Id"]
        table.insert(currentUnitIds, tostring(petId)) 
    end

    for _, child in pairs(petsFolder:GetChildren()) do
        if child:IsA("Folder") and not table.find(currentUnitIds, child.Name) then
            child:Destroy()
        end
    end
end


coroutine.wrap(function()
    task.wait(10)
    while true do
        updatePetsFolder()
        task.wait()
    end
end)()

do
    
    local function findHumanoidRootPart()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                return rootPart
            end
        end
    end

    local AutoBlowBubble = Tabs.Farm:CreateToggle("Auto Blow Bubble", {Title = "Auto Blow Bubble", Default = false, Description = ""})

    AutoBlowBubble:OnChanged(function(State)
        getgenv().AutoBlowBubble = State
        while getgenv().AutoBlowBubble == true do
            if not getgenv().AutoBlowBubble == true then return end
            task.wait(0.1)
            local args = {
                [1] = "BlowBubble"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))
        end
    end)

    local AutoCollectDrops = Tabs.Misc:CreateToggle("Auto Collect Drops", {Title = "Auto Collect Drops", Default = false, Description = ""})

    AutoCollectDrops:OnChanged(function(State)
        getgenv().CollectablesToggle = State
    end)

    local StatsUtil = require(game:GetService("ReplicatedStorage").Shared.Utils.Stats.StatsUtil)

    local oldGetPickupRange
    oldGetPickupRange = hookfunction(StatsUtil.GetPickupRange, function(...)
        if getgenv().CollectablesToggle then
            return math.huge
        end
        return oldGetPickupRange(...)
    end)

    local AutoCollectPlayTimeRewards = Tabs.Misc:CreateToggle("Auto Collect PlayTime Rewards", {Title = "Auto Collect Playtime Rewards", Default = false, Description = ""})

    AutoCollectPlayTimeRewards:OnChanged(function(State)
        getgenv().AutoCollectPlayTimeRewards = State
        while getgenv().AutoCollectPlayTimeRewards == true do
            if not getgenv().AutoCollectPlayTimeRewards == true then return end
            task.wait(10)
            for i = 1, 10 do
                task.wait(0.1)
                local args = {
                    [1] = "ClaimPlaytime",
                    [2] = i
                }
                
                game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Function"):InvokeServer(unpack(args))
            end

        end
    end)


    local AutoDoggyJump = Tabs.Misc:CreateToggle("AutoDoggyJump", {Title = "Auto Doggy Jump", Default = false, Description = ""})

    AutoDoggyJump:OnChanged(function(State)
        getgenv().AutoDoggyJump = State
        while getgenv().AutoDoggyJump == true do
            if not getgenv().AutoDoggyJump == true then return end
            task.wait(10)
            local args = {
                [1] = "DoggyJumpWin",
                [2] = 3
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))  
        end
    end)

    local AutoOpenMysteryBox = Tabs.Misc:CreateToggle("Auto Open Mystery Box", {Title = "Auto Open Mystery Box", Default = false, Description = ""})

    AutoOpenMysteryBox:OnChanged(function(State)
        getgenv().AutoOpenMysteryBox = State
        while getgenv().AutoOpenMysteryBox == true do
            if not getgenv().AutoOpenMysteryBox == true then return end
            task.wait(1)
            local args = {
                [1] = "UseGift",
                [2] = "Mystery Box",
                [3] = 10
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))
            task.wait(1)
            for i, v in pairs(workspace.Rendered.Gifts:GetChildren()) do
                local args = {
                    [1] = "ClaimGift",
                    [2] = v.Name
                }
                
                game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))     
            end
            task.wait(5)
            for i, v in pairs(workspace.Rendered.Gifts:GetChildren()) do
                v:Destroy()
            end
        end
    end)

    local AutoClaimSeason = Tabs.Misc:CreateToggle("Auto Claim Season", {Title = "Auto Claim Season Rewards", Default = false, Description = ""})

    AutoClaimSeason:OnChanged(function(State)
        getgenv().AutoClaimSeason = State
        while getgenv().AutoClaimSeason == true do
            if not getgenv().AutoClaimSeason == true then return end
            task.wait(1)
            local args = {
                [1] = "ClaimSeason"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))
        end
    end)


    local teleportRadius = 25
    local teleportSpeed = 30
    local tolerance = 2
    local offsetX, offsetY, offsetZ = 5, 10, 0

    local RunService = game:GetService("RunService")
    getgenv().TryingToTeleport = false
    local player = game.Players.LocalPlayer
    local function findHumanoidRootPart()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                return rootPart
            end
        end
    end

    local function moveToPart(enemy)
        if not enemy or not enemy:IsA("BasePart") then
            warn("Invalid enemy: Must be a BasePart with Position")
            return
        end

        local character = player.Character
        local hrp = findHumanoidRootPart(character)
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        if not character or not hrp or not humanoid then
            warn("No character, HumanoidRootPart, or Humanoid")
            return
        end

        local startPosition = hrp.Position
        local fixedY = startPosition.Y - 70
        local targetXZ = Vector3.new(enemy.Position.X + offsetX, fixedY, enemy.Position.Z + offsetZ)
        local finalY = enemy.Position.Y + offsetY
        local distanceXZ = (Vector3.new(hrp.Position.X, 0, hrp.Position.Z) - Vector3.new(targetXZ.X, 0, targetXZ.Z)).Magnitude

        if distanceXZ <= teleportRadius or getgenv().TryingToTeleport then
            return
        end

        getgenv().TryingToTeleport = true
        local isActive = true
        local connections = {}

        local function setNoclip(enabled)
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = not enabled
                end
            end
        end

        local function cleanup()
            isActive = false
            if humanoid then
                humanoid.PlatformStand = false
            end
            if hrp then
                hrp.Anchored = false
                hrp.Velocity = Vector3.new(0, 0, 0)
            end
            for _, conn in ipairs(connections) do
                conn:Disconnect()
            end
            setNoclip(false)
            getgenv().TryingToTeleport = false
        end

        local success, err = pcall(function()
            setNoclip(true)
            humanoid.PlatformStand = true

            local startTime = tick()
            local duration = distanceXZ / teleportSpeed

            table.insert(connections, RunService.Heartbeat:Connect(function(deltaTime)
                if not isActive or not hrp or not humanoid then
                    cleanup()
                    return
                end

                local elapsed = tick() - startTime
                local progress = math.clamp(elapsed / duration, 0, 1)
                local newXZ = Vector3.new(
                    startPosition.X + (targetXZ.X - startPosition.X) * progress,
                    fixedY,
                    startPosition.Z + (targetXZ.Z - startPosition.Z) * progress
                )

                local currentDistanceXZ = (Vector3.new(hrp.Position.X, 0, hrp.Position.Z) - Vector3.new(targetXZ.X, 0, targetXZ.Z)).Magnitude

                if currentDistanceXZ <= tolerance or progress >= 1 then
                    hrp.Velocity = Vector3.new(0, 0, 0)
                    hrp.Anchored = true
                    hrp.CFrame = CFrame.new(targetXZ.X, finalY, targetXZ.Z)
                    cleanup()
                    return
                end

                hrp.CFrame = CFrame.new(newXZ)
            end))

            table.insert(connections, humanoid.Died:Connect(cleanup))
            table.insert(connections, player.CharacterRemoving:Connect(cleanup))
        end)

        if not success then
            warn("Error during teleport:", err)
            cleanup()
        end
    end


    local function moveToSavedCoord()
        local character = player.Character
        local hrp = findHumanoidRootPart(character)
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        if not character or not hrp or not humanoid then
            warn("No character, HumanoidRootPart, or Humanoid")
            return
        end
    
        local targetPosition = getgenv().SavedPosition
        if not targetPosition then
            warn("No saved position found")
            return
        end
    
        local startPosition = hrp.Position
        local fixedY = startPosition.Y - 70
        local targetXZ = Vector3.new(targetPosition.X + offsetX, fixedY, targetPosition.Z + offsetZ)
        local finalY = targetPosition.Y + offsetY
        local distanceXZ = (Vector3.new(hrp.Position.X, 0, hrp.Position.Z) - Vector3.new(targetXZ.X, 0, targetXZ.Z)).Magnitude
    
        if distanceXZ <= teleportRadius or getgenv().TryingToTeleport then
            return
        end
    
        getgenv().TryingToTeleport = true
        local isActive = true
        local connections = {}
    
        local function setNoclip(enabled)
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = not enabled
                end
            end
        end
    
        local function cleanup()
            isActive = false
            if humanoid then
                humanoid.PlatformStand = false
            end
            if hrp then
                hrp.Anchored = false
                hrp.Velocity = Vector3.new(0, 0, 0)
            end
            for _, conn in ipairs(connections) do
                conn:Disconnect()
            end
            setNoclip(false)
            getgenv().TryingToTeleport = false
        end
    
        local success, err = pcall(function()
            setNoclip(true)
            humanoid.PlatformStand = true
    
            local startTime = tick()
            local duration = distanceXZ / teleportSpeed -- Calculate duration based on speed
    
            table.insert(connections, RunService.Heartbeat:Connect(function(deltaTime)
                if not isActive or not hrp or not humanoid then
                    cleanup()
                    return
                end
    
                local elapsed = tick() - startTime
                local progress = math.clamp(elapsed / duration, 0, 1)
                local newXZ = Vector3.new(
                    startPosition.X + (targetXZ.X - startPosition.X) * progress,
                    fixedY,
                    startPosition.Z + (targetXZ.Z - startPosition.Z) * progress
                )
    
                local currentDistanceXZ = (Vector3.new(hrp.Position.X, 0, hrp.Position.Z) - Vector3.new(targetXZ.X, 0, targetXZ.Z)).Magnitude
    
                if currentDistanceXZ <= tolerance or progress >= 1 then
                    hrp.Velocity = Vector3.new(0, 0, 0)
                    hrp.Anchored = true
                    hrp.CFrame = CFrame.new(targetXZ.X, finalY, targetXZ.Z)
                    cleanup()
                    return
                end
    
                hrp.CFrame = CFrame.new(newXZ)
            end))
    
            table.insert(connections, humanoid.Died:Connect(cleanup))
            table.insert(connections, player.CharacterRemoving:Connect(cleanup))
        end)
    
        if not success then
            warn("Error during teleport:", err)
            cleanup()
        end
    end
    
    local function moveToCoord(position)
        local character = player.Character
        local hrp = findHumanoidRootPart(character)
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        if not character or not hrp or not humanoid then
            warn("No character, HumanoidRootPart, or Humanoid")
            return
        end
    
        if not position then
            warn("No position provided")
            return
        end
    
        local startPosition = hrp.Position
        local fixedY = startPosition.Y - 70
        local targetXZ = Vector3.new(position.X + offsetX, fixedY, position.Z + offsetZ)
        local finalY = position.Y + offsetY
        local distanceXZ = (Vector3.new(hrp.Position.X, 0, hrp.Position.Z) - Vector3.new(targetXZ.X, 0, targetXZ.Z)).Magnitude
    
        if distanceXZ <= teleportRadius or getgenv().TryingToTeleport then
            return
        end
    
        getgenv().TryingToTeleport = true
        local isActive = true
        local connections = {}
    
        local function setNoclip(enabled)
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = not enabled
                end
            end
        end
    
        local function cleanup()
            isActive = false
            if humanoid then
                humanoid.PlatformStand = false
            end
            if hrp then
                hrp.Anchored = false
                hrp.Velocity = Vector3.new(0, 0, 0)
            end
            for _, conn in ipairs(connections) do
                conn:Disconnect()
            end
            setNoclip(false)
            getgenv().TryingToTeleport = false
        end
    
        local success, err = pcall(function()
            setNoclip(true)
            humanoid.PlatformStand = true
    
            local startTime = tick()
            local duration = distanceXZ / teleportSpeed -- Calculate duration based on speed
    
            table.insert(connections, RunService.Heartbeat:Connect(function(deltaTime)
                if not isActive or not hrp or not humanoid then
                    cleanup()
                    return
                end
    
                local elapsed = tick() - startTime
                local progress = math.clamp(elapsed / duration, 0, 1)
                local newXZ = Vector3.new(
                    startPosition.X + (targetXZ.X - startPosition.X) * progress,
                    fixedY,
                    startPosition.Z + (targetXZ.Z - startPosition.Z) * progress
                )
    
                local currentDistanceXZ = (Vector3.new(hrp.Position.X, 0, hrp.Position.Z) - Vector3.new(targetXZ.X, 0, targetXZ.Z)).Magnitude
    
                if currentDistanceXZ <= tolerance or progress >= 1 then
                    hrp.Velocity = Vector3.new(0, 0, 0)
                    hrp.Anchored = true
                    hrp.CFrame = CFrame.new(targetXZ.X, finalY, targetXZ.Z)
                    cleanup()
                    return
                end
    
                hrp.CFrame = CFrame.new(newXZ)
            end))
    
            table.insert(connections, humanoid.Died:Connect(cleanup))
            table.insert(connections, player.CharacterRemoving:Connect(cleanup))
        end)
    
        if not success then
            warn("Error during teleport:", err)
            cleanup()
        end
    end

    

    local savedPositionString = readfile(PositionfolderPath)
    local positionValues = {}

    -- Разделяем строку на отдельные координаты
    for value in string.gmatch(savedPositionString, "[^,]+") do
        table.insert(positionValues, tonumber(value))
    end

    -- Проверяем, что у нас есть три координаты
    if #positionValues == 3 then
        -- Создаем CFrame из координат
        getgenv().SavedPosition = Vector3.new(positionValues[1], positionValues[2], positionValues[3])
        print("Сохраненная позиция установлена:", getgenv().SavedPosition)
    else
        warn("Ошибка: неверное количество координат в файле.")
    end

    local currentPositionParagraph = Tabs.Eggs:CreateParagraph("Current pos paragraph", {
        Title = "Current Position",
        Content = "Position: "..savedPositionString
    })
    
    local function updatePosition()

        local HumanoidRootPart = findHumanoidRootPart()
        getgenv().SavedPosition = HumanoidRootPart.Position
        writefile(PositionfolderPath, tostring(getgenv().SavedPosition.x)..","..tostring(getgenv().SavedPosition.y)..","..tostring(getgenv().SavedPosition.z))
        currentPositionParagraph:SetValue("Position: " .. tostring(getgenv().SavedPosition))
    end
    
    Tabs.Eggs:CreateButton({
        Title = "Save New Position",
        Description = "Change your position for auto teleport",
        Callback = function()
            -- Вызываем функцию обновления позиции и карты
            updatePosition()
        end
    })
    
    local function teleportToSavedPosition()
        if getgenv().SavedPosition then
            moveToSavedCoord()
        else
            warn("Saved world or position is not set.")
        end
    end

    Tabs.Eggs:CreateButton({
        Title = "Teleport To Saved Position",
        Description = "",
        Callback = function()
            teleportToSavedPosition()
        end
    })
    

    local function getEggList()
        local Shalom = require(game:GetService("ReplicatedStorage").Shared.Data.Eggs)
        local AvatarsData = Shalom
        local EggList = {}
        for i,v in pairs(AvatarsData) do
            table.insert(EggList, tostring(i))
        end
        return EggList
    end

    local egglist = getEggList()
    table.insert(egglist, "Infinity Egg")

    local currenteggforfarm = nil
    local EggsDropDown = Tabs.Eggs:CreateDropdown("Egg List", {Title = "Select Egg For Auto Open", Description = "", Values = egglist,Searchable = true, Multi = false, Default = 1,})
    EggsDropDown:OnChanged(function(Value)
        currenteggforfarm = Value
        print(currenteggforfarm)
    end)

    getgenv().AmountOfEggs = 1
    local AmountOfEggForOpen = Tabs.Eggs:CreateInput("Amount Of Eggs", {
        Title = "Amount Of Eggs For Auto Open",
        Default = 1, 
        Description = "",
        Numeric = true,
        Finished = false,
        Callback = function(Value)
            getgenv().AmountOfEggs = tonumber(Value)
        end
    })
    AmountOfEggForOpen:OnChanged(function(Value)
        getgenv().AmountOfEggs = tonumber(Value)
    end)

    local AutoOpenEggs = Tabs.Eggs:CreateToggle("Auto Open Eggs", {Title = "Auto Open Selected Egg", Default = false, Description = ""})

    local function checkRadiusForEgg()
        local Radius = 20
        local Generic = workspace.Rendered and Workspace.Rendered.Generic
        local Egg = Generic and Generic:FindFirstChild(EggsDropDown.Value)
        if Egg then
            if Egg:GetAttribute("Size") ~= nil then
                local HumanoidRootPart = findHumanoidRootPart()
                local Distance = (HumanoidRootPart.Position - Egg.PrimaryPart.Position).Magnitude
                if Distance <= Radius then
                    return true
                end
            end
        end
        return false
    end
    AutoOpenEggs:OnChanged(function(state)
        getgenv().AutoOpenEggs = state
        while getgenv().AutoOpenEggs do
            task.wait()
            if checkRadiusForEgg() then
                local args = {
                    [1] = "HatchEgg",
                    [2] = EggsDropDown.Value,
                    [3] = getgenv().AmountOfEggs
                }
                        
                game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))        
            end
        end
    end)


    local egglist2 = getEggList()
    table.insert(egglist2, "Man Egg")

    local currentRifteggforfarm = nil
    local RiftEggsDropDown = Tabs.Eggs:CreateDropdown("Egg Rift List", {Title = "Select Rift Egg For Auto Open", Description = "", Values = egglist2, Searchable = true, Multi = true, Default = {}})
    
    function RiftEggsDropDown:GetSelectedValues()
        local selected = {}
        for value, state in pairs(self.Value) do
            if state then
                table.insert(selected, value)
            end
        end
        return selected
    end

    local function containsValue(value, table)
        for _, v in ipairs(table) do
            if v == value then
                return true
            end
        end
        return false
    end

    local RiftFolder = workspace.Rendered.Rifts

    local function findNearestIsland()
        local highestLuckIsland = nil
        local highestLuckValue = -math.huge
        local rootPart = findHumanoidRootPart()
    
        local SelectedIslands = RiftEggsDropDown:GetSelectedValues()
        if #SelectedIslands > 0 then
            for _, enemy in pairs(RiftFolder:GetDescendants()) do
                if enemy:IsA("Model") then
                    local rnenemyname = enemy.Name
                    rnenemyname = string.gsub(rnenemyname, "-", " ")
                    rnenemyname = string.gsub(rnenemyname, "(%a)(%w*)", function(first, rest) 
                        return first:upper() .. rest:lower() 
                    end)
                    local checkname = rnenemyname
                    if rnenemyname == "Event 1" or rnenemyname == "Event 2" or rnenemyname == "Event 3" then
                        if rnenemyname == "Event 1" then
                            checkname = "Bunny Egg"
                        elseif rnenemyname == "Event 2" then
                            checkname = "Pastel Egg"
                        elseif rnenemyname == "Event 3" then
                            checkname = "Throwback Egg"
                        end
                    end
    
                    if containsValue(checkname, SelectedIslands) then
                        local display = enemy:FindFirstChild("Display")
                        local surfaceGui = display and display:FindFirstChild("SurfaceGui")
                        local icon = surfaceGui and surfaceGui:FindFirstChild("Icon")
                        local luckLabel = icon and icon:FindFirstChild("Luck")
    
                        if luckLabel and luckLabel:IsA("TextLabel") then
                            local luckText = luckLabel.Text
                            local luckValue = tonumber(string.match(luckText, "x(%d+)"))
                            
                            if luckValue and luckValue > highestLuckValue then
                                highestLuckValue = luckValue
                                local partforteleport = enemy:FindFirstChild("Decoration")
                                local partforteleport2 = partforteleport and partforteleport:FindFirstChild("Meshes/floatingisland1_Circle.003")
                                if partforteleport2 then
                                    highestLuckIsland = partforteleport2
                                end
                            end
                        end
                    end
                end
            end
        end
    
        return highestLuckIsland
    end

    local function findNearestEgg()
        local closestIsland = nil
        local closestDistance = math.huge
        local rootPart = findHumanoidRootPart()
        local closestEggName = nil
        local SelectedIslands = RiftEggsDropDown:GetSelectedValues()
        if #SelectedIslands > 0 then
            for _, enemy in pairs(RiftFolder:GetDescendants()) do
                if enemy:IsA("Model") then
                    local rnenemyname = enemy.Name
                        rnenemyname = string.gsub(rnenemyname, "-", " ")
                        rnenemyname = string.gsub(rnenemyname, "(%a)(%w*)", function(first, rest) 
                            return first:upper() .. rest:lower() 
                        end)

        
                        local checkname = rnenemyname
                        if rnenemyname == "Event 1" or rnenemyname == "Event 2" or rnenemyname == "Event 3" then
                            if rnenemyname == "Event 1" then
                                checkname = "Bunny Egg"
                            end
    
                            if rnenemyname == "Event 2" then
                                checkname = "Pastel Egg"
                            end
    
                            if rnenemyname == "Event 3" then
                                checkname = "Throwback Egg"
                            end
                        end
    



                    local partforteleport = enemy:FindFirstChild("Decoration")
                    if partforteleport then
                        local partforteleport2 = partforteleport:FindFirstChild("Meshes/floatingisland1_Circle.003")
                        if partforteleport2 and rootPart then
                            if partforteleport2.Position and rootPart.Position then
                                local distance = (rootPart.Position - partforteleport2.Position).Magnitude
                    
                                if containsValue(checkname, SelectedIslands) and distance < closestDistance then
                                    closestDistance = distance
                                    closestIsland = partforteleport2
                                    closestEggName = checkname
                                end
                            end
                        end
                    end
                end
            end
        end

    
        return closestEggName
    end

    getgenv().TryingToOpenRiftChest = false
    getgenv().TryingToOpenRiftEgg = false
    coroutine.wrap(function()
        while true do
            task.wait(25)
            getgenv().TryingToOpenRiftEgg = false
            getgenv().TryingToOpenRiftChest = false

        end
    end)()
    local AutoOpenRiftEggs = Tabs.Eggs:CreateToggle("Auto Open Rift Eggs", {Title = "Auto Open Selected Rift Eggs", Default = false, Description = ""})
    AutoOpenRiftEggs:OnChanged(function(state)
        getgenv().AutoOpenRiftEggs = state
            if getgenv().AutoOpenRiftEgg == false then
                getgenv().TryingToOpenRiftEgg = false
            end

            coroutine.wrap(function()
                while getgenv().AutoOpenRiftEgg == true do
                    task.wait(15)
                    getgenv().TryingToOpenRiftEgg = false
                end
            end)()

            local function teleportToNearestIsland()
                local nearestIsland = findNearestIsland()
                if getgenv().TryingToOpenRiftChest == false then
                    local hm = findHumanoidRootPart()
                    if nearestIsland  and hm and getgenv().FarminCoins == false then
                        moveToPart(nearestIsland)

                    end
                end
            end

            coroutine.wrap(function()
                while getgenv().AutoOpenRiftEggs == true do
                    task.wait()
                    teleportToNearestIsland()
                    task.wait(13)
                end
            end)()

            local function OpenNearestEgg()
                local nearestEgg = findNearestEgg()
                if nearestEgg ~= nil then
                    if getgenv().TryingToOpenRiftChest == false then
                    getgenv().TryingToOpenRiftEgg = true
                    local args = {
                        [1] = "HatchEgg",
                        [2] = nearestEgg,
                        [3] = getgenv().AmountOfEggs
                    }
                    
                    game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))
                    end
                end
            end

            coroutine.wrap(function()
                while getgenv().AutoOpenRiftEggs == true do
                    task.wait(0.1)
                    OpenNearestEgg()
                end
            end)()

            coroutine.wrap(function()
                while getgenv().AutoOpenRiftEggs == true do
                    task.wait()
                    local nearestIsland = findNearestIsland()
                    local hm = findHumanoidRootPart()
                    if nearestIsland == nil and getgenv().TryingToOpenRiftEgg == false and getgenv().TryingToOpenRiftChest == false and hm and getgenv().FarminCoins == false then
                        moveToSavedCoord()
                        getgenv().TryingToOpenRiftEgg = false
                    end
                    task.wait(13)
                end
            end)()


    end)

    local AnimationsToggle = Tabs.Eggs:CreateToggle("AnimationsToggle", {Title = "Auto Cancel Open Animation", Description = "", Default = false})
    AnimationsToggle:OnChanged(function(state)
        getgenv().AnimationsToggle = state
    end)

    local ClientHatchEgg = require(game:GetService('ReplicatedStorage').Client.Effects.HatchEgg)

    local oldAnimations
    oldAnimations = hookfunction(ClientHatchEgg.Play, function(...)
        if getgenv().AnimationsToggle then
            return true
        end
        return oldAnimations(...)
    end)

    local function unlockAllIslands()
        for i, v in pairs(workspace.Worlds["The Overworld"].Islands:GetDescendants()) do
            if v.Name == "UnlockHitbox" then
                local hm = findHumanoidRootPart()
                hm.CFrame = CFrame.new(v.Position)
                task.wait(0.1)
            end
        end
    end

    Tabs.Teleport:CreateButton{
        Title = "Unlock All Islands",
        Description = "",
        Callback = function()
            unlockAllIslands()
        end
    }
    
    Tabs.Teleport:CreateButton{
        Title = "Teleport to Spawn",
        Description = "",
        Callback = function()
            local args = {
                [1] = "Teleport",
                [2] = "Workspace.Worlds.The Overworld.PortalSpawn"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))
        end
    }

    for i, v in pairs(workspace.Worlds["The Overworld"].Islands:GetChildren()) do
        Tabs.Teleport:CreateButton{
            Title = "Teleport to "..tostring(v.Name),
            Description = "",
            Callback = function()
                local args = {
                    [1] = "Teleport",
                    [2] = "Workspace.Worlds.The Overworld.Islands."..tostring(v.Name)..".Island.Portal.Spawn"
                }
                
                game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))     
            end
        }
    end


    local AutoUpgradeBuffsMastery = Tabs.Misc:CreateToggle("AutoUpgradeBuffsMastery", {Title = "Auto Upgrade Buffs Mastery", Default = false, Description = ""})

    AutoUpgradeBuffsMastery:OnChanged(function(state)
        getgenv().AutoUpgradeBuffsMastery = state
        while getgenv().AutoUpgradeBuffsMastery do
            task.wait(10)
            local args = {
                [1] = "UpgradeMastery",
                [2] = "Buffs"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))
        end
    end)

    local AutoUpgradePetsMastery = Tabs.Misc:CreateToggle("AutoUpgradePetsMastery", {Title = "Auto Upgrade Pets Mastery", Default = false, Description = ""})

    AutoUpgradePetsMastery:OnChanged(function(state)
        getgenv().AutoUpgradePetsMastery = state
        while getgenv().AutoUpgradePetsMastery do
            task.wait(10)
            local args = {
                [1] = "UpgradeMastery",
                [2] = "Pets"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))
        end
    end)

    local AutoUpgradeShopsMastery = Tabs.Misc:CreateToggle("AutoUpgradeShopsMastery", {Title = "Auto Upgrade Shops Mastery", Default = false, Description = ""})

    AutoUpgradeShopsMastery:OnChanged(function(state)
        getgenv().AutoUpgradeShopsMastery = state
        while getgenv().AutoUpgradeShopsMastery do
            task.wait(10)
            local args = {
                [1] = "UpgradeMastery",
                [2] = "Shops"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))            
        end
    end)



    
    local AutoSpinWheel = Tabs.Misc:CreateToggle("AutoSpinWheel", {Title = "Auto Spin Wheel", Default = false, Description = ""})

    AutoSpinWheel:OnChanged(function(state)
        getgenv().AutoSpinWheel = state
        while getgenv().AutoSpinWheel do
            task.wait(10)
            local args = {
                [1] = "ClaimFreeWheelSpin"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))
            task.wait()
            local args = {
                [1] = "WheelSpin"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Function"):InvokeServer(unpack(args))
            task.wait()
            local args = {
                [1] = "ClaimWheelSpinQueue"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))            
        end
    end)
    

    local AutoAcceptGenieQuest = Tabs.Misc:CreateToggle("AutoAcceptGenieQuest", {Title = "Auto Accept Genie Quest", Default = false, Description = ""})

    AutoAcceptGenieQuest:OnChanged(function(state)
        getgenv().AutoAcceptGenieQuest = state
        while getgenv().AutoAcceptGenieQuest do
            task.wait(10)
            local args = {
                [1] = "StartGenieQuest",
                [2] = 3
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))
        end
    end)
    
    local chestsList = {"golden-chest", "royal-chest"}


    local RiftChestsDropdown = Tabs.Chests:CreateDropdown("Chests Rift List", {Title = "Select Rift Chest For Auto Open", Description = "", Values = chestsList, Multi = false, Default = {}})

    local function findNearestIslandForChest()
        local closestIsland = nil
        local closestDistance = math.huge
        local rootPart = findHumanoidRootPart()
    
        for _, enemy in pairs(RiftFolder:GetDescendants()) do
            if enemy:IsA("Model") then
                local rnenemyname = enemy.Name
                if rnenemyname == RiftChestsDropdown.Value then
                    local partforteleport = enemy:FindFirstChild("Chest")
                    if partforteleport then
                        local partforteleport2 = partforteleport:FindFirstChild("Inner")
                        if partforteleport2 and rootPart then
                            if partforteleport2.Position and rootPart.Position then
                                local distance = (rootPart.Position - partforteleport2.Position).Magnitude
                                if enemy:GetAttribute("Type") == "Chest" then
                                    if distance < closestDistance then
                                        closestDistance = distance
                                        closestIsland = partforteleport2
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    
        return closestIsland
    end

    local function findNearestChest()
        local closestIsland = nil
        local closestDistance = math.huge
        local rootPart = findHumanoidRootPart()
        local closestChestName = nil
        --local SelectedChests = RiftChestsDropdown:GetSelectedValues()
            for _, enemy in pairs(RiftFolder:GetDescendants()) do
                if enemy:IsA("Model") then
                    local rnenemyname = enemy.Name
                    if rnenemyname == RiftChestsDropdown.Value then
                        local partforteleport = enemy:FindFirstChild("Chest")
                        if partforteleport then
                            local partforteleport2 = partforteleport:FindFirstChild("Inner")
                            if partforteleport2 and rootPart then
                                if partforteleport2.Position and rootPart.Position then
                                    local distance = (rootPart.Position - partforteleport2.Position).Magnitude

                                    if enemy:GetAttribute("Type") == "Chest" then
                                        if distance < closestDistance then
                                        closestDistance = distance
                                        closestIsland = partforteleport2
                                        closestChestName = rnenemyname
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end


        return closestChestName
    end


    local AutoOpenRiftChests = Tabs.Chests:CreateToggle("Auto Open Rift Chest", {Title = "Auto Open  Rift Chests", Default = false, Description = "THIS WONT TELEPORT YOU BACK IF YOU HAVE 0 KEYS"})
    AutoOpenRiftChests:OnChanged(function(state)
        getgenv().AutoOpenRiftChests = state
            if  state == false then
                getgenv().TryingToOpenRiftChest = false
                if activeTween then
                    task.wait(1)
                    activeTween:Cancel()  -- Stop the active tween
                    activeTween = nil      -- Reset the active tween variable
                end
            end

            coroutine.wrap(function()
                while getgenv().AutoOpenRiftChests == true do
                    task.wait(30)
                    getgenv().TryingToOpenRiftChest = false
                end
            end)()

            local function teleportToNearestIslandForChest()
                local nearestIsland = findNearestIslandForChest()
                local nearestChest = findNearestChest()

                if nearestIsland then
                    local hm = findHumanoidRootPart()
                    if nearestChest and hm and getgenv().FarminCoins == false then
                        getgenv().TryingToOpenRiftChest = true
                        moveToPart(nearestIsland)
                    end
                end
            end

            coroutine.wrap(function()
                while getgenv().AutoOpenRiftChests == true do
                    task.wait()
                    teleportToNearestIslandForChest()
                    task.wait(13)
                end
            end)()

            local function OpenNearestChest()
                local nearestChest = findNearestChest()

                if nearestChest ~= nil then
                    if nearestChest then
                        getgenv().TryingToOpenRiftChest = true
                        local args = {
                            [1] = "UnlockRiftChest",
                            [2] = nearestChest,
                            [3] = false
                        }
                        
                        game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))
                        
                    end
                else
                    getgenv().TryingToOpenRiftChest = false
                end
            end

            coroutine.wrap(function()
                while getgenv().AutoOpenRiftChests == true do
                    task.wait()
                    OpenNearestChest()
                end
            end)()

            coroutine.wrap(function()
                while getgenv().AutoOpenRiftChests == true do
                    task.wait()
                    local nearestIsland = findNearestIslandForChest()
                    local hm = findHumanoidRootPart()
                    if nearestIsland == nil and getgenv().TryingToOpenRiftEgg == false and getgenv().TryingToOpenRiftChest == false and hm and getgenv().FarminCoins == false then
                        getgenv().TryingToOpenRiftChest = false
                        moveToSavedCoord()
                        getgenv().TryingToOpenRiftChest = false
                    end
                    task.wait(13)
                end
            end)()


    end)

    local AutoClaimGiantChest = Tabs.Chests:CreateToggle("AutoClaimGiantChest", {Title = "Auto Claim Giant Chest", Default = false, Description = ""})

    AutoClaimGiantChest:OnChanged(function(state)
        getgenv().AutoClaimGiantChest = state
        while getgenv().AutoClaimGiantChest do
            task.wait(0)
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
            local Data = LocalData:Get()
            local Cooldown = Data.Cooldowns["Giant Chest"]
            local timestamp = os.time()
            if Cooldown and timestamp then
                if timestamp>Cooldown then
                    local args = {
                        [1] = "ClaimChest",
                        [2] = "Giant Chest"
                    }
                    
                    game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))          
                end
            end
        end
    end)

    local AutoClaimInfinityChest = Tabs.Chests:CreateToggle("AutoClaimInfinityChest", {Title = "Auto Claim Infinity Chest", Default = false, Description = ""})

    AutoClaimInfinityChest:OnChanged(function(state)
        getgenv().AutoClaimInfinityChest = state
        while getgenv().AutoClaimInfinityChest do
            task.wait(0)
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
            local Data = LocalData:Get()
            local Cooldown = Data.Cooldowns["Infinity Chest"]
            local timestamp = os.time()
            if Cooldown and timestamp then
                if timestamp>Cooldown then
                    local args = {
                        [1] = "ClaimChest",
                        [2] = "Infinity Chest"
                    }
                    
                    game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))          
                end
            end
        end
    end)

    local AutoClaimVoidChest = Tabs.Chests:CreateToggle("AutoClaimVoidChest", {Title = "Auto Claim Void Chest", Default = false, Description = ""})

    AutoClaimVoidChest:OnChanged(function(state)
        getgenv().AutoClaimVoidChest = state
        while getgenv().AutoClaimVoidChest do
            task.wait(0)
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
            local Data = LocalData:Get()
            local Cooldown = Data.Cooldowns["Void Chest"]
            local timestamp = os.time()
            if Cooldown and timestamp then
                if timestamp>Cooldown then
                    local args = {
                        [1] = "ClaimChest",
                        [2] = "Void Chest"
                    }
                    
                    game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))          
                end
            end
        end
    end)


    local AutoBuyAlienShop = Tabs.AutoBuy:CreateToggle("AutoBuyAlienShop", {Title = "Auto Buy Alien Shop", Default = false, Description = ""})

    AutoBuyAlienShop:OnChanged(function(state)
        getgenv().AutoBuyAlienShop = state
        while getgenv().AutoBuyAlienShop do
            task.wait(5)
            for i = 1, 3 do
                task.wait()
                local args = {
                    [1] = "BuyShopItem",
                    [2] = "alien-shop",
                    [3] = i
                }
                
                game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))
            end
        end
    end)

    local AutoBuyBlackMarket = Tabs.AutoBuy:CreateToggle("AutoBuyBlackMarket", {Title = "Auto Buy Blackmarket", Default = false, Description = ""})

    AutoBuyBlackMarket:OnChanged(function(state)
        getgenv().AutoBuyBlackMarket = state
        while getgenv().AutoBuyBlackMarket do
            task.wait(5)
            for i = 1, 3 do
                task.wait()
                local args = {
                    [1] = "BuyShopItem",
                    [2] = "shard-shop",
                    [3] = i
                }
                
                game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))
            end
        end
    end)

    local function getListOfEnchants()
        local Shalom = require(game:GetService("ReplicatedStorage").Shared.Data.Enchants)
    
        local AvatarsData = Shalom
        local TableofEnchants = {}
        if type(AvatarsData) == "table" then
            for i,v in pairs(AvatarsData) do
                for o, p in pairs(v) do
                    if tostring(o) == "Levels" then
                        local NumberOfLevels = tonumber(p)
                        for l = 1, NumberOfLevels do
                            table.insert(TableofEnchants, tostring(i) .. " " .. tostring(l))
                        end
                    end
                end
            end
        end
        return TableofEnchants
    end

    local EnchantList = getListOfEnchants()

    local function getExistingUnitIds()
        local petsFolder = game:GetService("Players").LocalPlayer:FindFirstChild("Pets")
        if petsFolder then
            local existingUnitIds = {}
            for _, child in pairs(petsFolder:GetChildren()) do
                if child:IsA("Folder") then
                    if child.Enchants:FindFirstChild("2") then
                        local stringfortable = tostring(child:GetAttribute("Name")).. " | Enchant 1: " .. tostring(child.Enchants:FindFirstChild("1"):GetAttribute("Enchant")) .. " | Enchant 2: " .. tostring(child.Enchants:FindFirstChild("2"):GetAttribute("Enchant")).." | ID: "..child.Name
                        table.insert(existingUnitIds, stringfortable)
                    else
                        local stringfortable = tostring(child:GetAttribute("Name")).. " | Enchant 1: " .. tostring(child.Enchants:FindFirstChild("1"):GetAttribute("Enchant")).." | ID: "..child.Name
                        table.insert(existingUnitIds, stringfortable)
                    end
                end
            end
            return existingUnitIds
        end
    end

    
    
    local petslist = getExistingUnitIds()

    local PassiveParagraph = Tabs.Enchants:CreateParagraph("Current Enchants", {
        Title = "Current Enchants: ",
        Content = nil
    })

    local PetsDropdown = Tabs.Enchants:CreateDropdown("Pets Dropdown", {Title = "Select Pet For Auto Reroll Enchant", Description = "", Values = petslist, Multi = false,Searchable = true , Default = ""})
    
    local EnchantsDropdown = Tabs.Enchants:CreateDropdown("Enchants Dropdown", {Title = "Select Enchants For Auto Reroll", Description = "Allows Multi", Values = EnchantList,Searchable = true, Multi = true, Default = {}})
    

    local function getselectedid()
        local selectedPet = PetsDropdown.Value
        if selectedPet and type(selectedPet) ~= "table" then
            local idStart = selectedPet:find("ID: ")
            if idStart then
                local id = selectedPet:sub(idStart + 4)
                return id
            end
        end
        return nil
    end
    
    local function updatePetsDropdownAndSelect()
        local selectedId = getselectedid()
        local newpetlist = getExistingUnitIds()
        PetsDropdown:SetValues(newpetlist)
    

        if selectedId then

            for _, pet in pairs(newpetlist) do
                if pet:find("ID: " .. selectedId) then
                    PetsDropdown:SetValue(pet)
                    break
                end
            end
        end
    end

    local RefreshPets = Tabs.Enchants:CreateButton({
        Title = "Refresh Pets",
        Description = "",
        Callback = function()
            updatePetsDropdownAndSelect()
        end
    })

    function EnchantsDropdown:GetSelectedValues()
        local selected = {}
        for value, state in pairs(self.Value) do
            if state then
                table.insert(selected, value)
            end
        end
        return selected
    end

    local function rerollEnchant(id)
        local args = {
            [1] = "RerollEnchants",
            [2] = id
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Function"):InvokeServer(unpack(args))
    end

    local function getCurrentEnchants(id)
        local tableOfenchants = {}
        local petsFolder = player:FindFirstChild('Pets')
        if petsFolder then
            local pet = petsFolder:FindFirstChild(id)
            if pet then
                local EnchantsFolder = pet:FindFirstChild("Enchants")
                if EnchantsFolder then
                    local numberofEnchants = #EnchantsFolder:GetChildren()
                    if numberofEnchants == 2 then
                        local firstEnchant = EnchantsFolder:FindFirstChild("1"):GetAttribute("Enchant")
                        local secondEnchant = EnchantsFolder:FindFirstChild("2"):GetAttribute("Enchant")
                        table.insert(tableOfenchants, firstEnchant)
                        table.insert(tableOfenchants, secondEnchant)
                        return tableOfenchants
                    else
                        local firstEnchant = EnchantsFolder:FindFirstChild("1"):GetAttribute("Enchant")
                        table.insert(tableOfenchants, firstEnchant)
                        return tableOfenchants
                    end
                end
            end
        end
    end

    local function containsValueTable(CurrentPassives, selectedPassives)

        if type(CurrentPassives) ~= "table" then
            warn("Ошибка 1")
            return false 
        end
    
        if type(selectedPassives) ~= "table" then
            warn("Ошибка 2")
            return false
        end
    
        for _, selected in ipairs(CurrentPassives) do
            for _, current in ipairs(selectedPassives) do
                if selected == current then
                    return true
                end
            end
        end
        return false
    end

    local AutoRerollEnchant = Tabs.Enchants:CreateToggle("Auto Reroll passive",{Title = "Auto Roll For Selected Passive", Description = "YOU MUST BE IN PASSIVE REROLL CIRCLE", Default = false})

    AutoRerollEnchant:OnChanged(function(state)
        getgenv().AutoRerollEnchant = state
        while getgenv().AutoRerollEnchant do
            task.wait()
            local selectedPetId = getselectedid()
            local selectedPassives = EnchantsDropdown:GetSelectedValues()
    
            if #selectedPassives == 0 then
                AutoRerollEnchant:SetValue(false)
                PetsDropdown:SetValue("")
                updatePetsDropdownAndSelect()
                getgenv().AutoRerollEnchant = false
            else
                if selectedPetId then
                    local currentpassives = getCurrentEnchants(selectedPetId)
                    if containsValueTable(currentpassives, selectedPassives) then
                        AutoRerollEnchant:SetValue(false)
                        PetsDropdown:SetValue("")
                        updatePetsDropdownAndSelect()
                        getgenv().AutoRerollEnchant = false
                    else
                        rerollEnchant(selectedPetId)
                    end
                end
            end
        end

    end)

    getgenv().AutoFarmCoinsLimit = 1
    local AutoFarmCoinsLimit = Tabs.Farm:CreateInput("Amount Of Coins Limit", {
        Title = "Amount Of Coins For Auto Farm",
        Default = 100000000000, 
        Description = "",
        Numeric = true,
        Finished = false,
        Callback = function(Value)
            getgenv().AutoFarmCoinsLimit = tonumber(Value)
        end
    })
    local CoinPotionToUse = nil
    local CoinPotionDropdown = Tabs.Farm:CreateDropdown("Coin Potion List", {Title = "Select Potion For Auto Use", Description = "1 - COINS I, 6 - COINS EVOLVED", Values = {1, 2, 3, 4, 5, 6}, Multi = false, Default = 1,})
    CoinPotionDropdown:OnChanged(function(Value)
        CoinPotionToUse = Value
    end)

    AutoFarmCoinsLimit:OnChanged(function(Value)
        getgenv().AutoFarmCoinsLimit = tonumber(Value)
    end)

    local AutoFarmCoins = Tabs.Farm:CreateToggle("AutoFarmCoins", {Title = "Auto Farm Coins if less than 500 Million (FARMING UNTIL SELECTED AMOUNT)", Default = false, Description = "MUST ENABLE AUTO COLLECT"})
    local function checkCoins()
        local LocalData = require(game:GetService("ReplicatedStorage").Client.Framework.Services.LocalData)
        local Data = LocalData:Get()
        local Coins = tonumber(Data.Coins)
        return Coins
    end

    
    local function checkAndUsePot()
        local LocalData = require(game:GetService("ReplicatedStorage").Client.Framework.Services.LocalData)
        local Data = LocalData:Get()
        local ActivePotion = Data.ActivePotions
        local ActiveBuffs = Data.ActiveBuffs
        local checker = false
        for i, v in pairs(ActiveBuffs) do
            if type(v) == "table" then
                for o, p in pairs(v) do
                    if tostring(p) == "GoldRush" then
                        checker = true
                    end
                end
            end
        end

        if checker == false then
            local args = {
                [1] = "UseGoldenOrb"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))            
        end

        if ActivePotion and ActivePotion.Coins and ActivePotion.Coins.Active and tonumber(ActivePotion.Coins.Active.Level) == CoinPotionToUse then
            CoinPotionToUse = CoinPotionToUse
        else
            local args = {
                [1] = "UsePotion",
                [2] = "Coins",
                [3] = tonumber(CoinPotionToUse)
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args)) 
        end
    end
    
    local coordForTp = Vector3.new(-46.28042984008789, 15971.724609375, 15.993919372558594)
    getgenv().FarminCoins = false
    AutoFarmCoins:OnChanged(function(State)
        getgenv().AutoFarmCoins = State
        if State == false then
            getgenv().FarminCoins = false
        end
        while getgenv().AutoFarmCoins == true do
            if not getgenv().AutoFarmCoins == true then return end
            task.wait(5)
            local Coins = checkCoins()
            if Coins < getgenv().AutoFarmCoinsLimit then
                if getgenv().FarminCoins == true then
                    pcall(checkAndUsePot)
                    getgenv().FarminCoins = true
                    moveToCoord(coordForTp)
                end
                if Coins < 500000000 then
                    pcall(checkAndUsePot)
                    getgenv().FarminCoins = true
                    moveToCoord(coordForTp)
                end
            elseif getgenv().FarminCoins == true and Coins >= getgenv().AutoFarmCoinsLimit then
                getgenv().FarminCoins = false
                moveToSavedCoord()
            end
        end
    end)
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local HttpService = game:GetService("HttpService")
    local Players = game:GetService("Players")

    local Pets = ReplicatedStorage.Shared:FindFirstChild("Data") and require(ReplicatedStorage.Shared.Data.Pets)
    local LocalDataService = ReplicatedStorage.Client:FindFirstChild("Framework") and require(ReplicatedStorage.Client.Framework.Services.LocalData)

    if not (Pets and LocalDataService) then
        warn("ERROR: Pets or LocalDataService not found")
        return
    end

    -- Инициализация переменных
    getgenv().WEBHOOK_URL = ""
    getgenv().DISCORD_USER_ID = ""
    getgenv().SELECTED_RARITIES = {}
    getgenv().SELECTED_PETS = {}
    getgenv().EMBED_COLOR = 0xFF69B4

    -- UI компоненты
    local DiscorUserId = Tabs.Eggs:CreateInput("DiscorUserId", {
        Title = "Discord User Id",
        Default = 0,
        Description = "Your Discord User Id",
        Numeric = false,
        Finished = false,
        Callback = function(Value)
            getgenv().DISCORD_USER_ID = tostring(Value)
        end
    })
    DiscorUserId:OnChanged(function(Value)
        getgenv().DISCORD_USER_ID = tostring(Value)
    end)

    local WebhookLink = Tabs.Eggs:CreateInput("WebhookLink", {
        Title = "Webhook Link",
        Default = 0,
        Description = "Your webhook link",
        Numeric = false,
        Finished = false,
        Callback = function(Value)
            getgenv().WEBHOOK_URL = tostring(Value)
        end
    })
    WebhookLink:OnChanged(function(Value)
        getgenv().WEBHOOK_URL = tostring(Value)
    end)

    local RaritiesDropdown = Tabs.Eggs:CreateDropdown("RaritiesDropdown", {
        Title = "Select Rarity For Webhook",
        Description = "",
        Values = {"Common", "Unique", "Rare", "Epic", "Legendary", "Secret"},
        Searchable = true,
        Multi = true,
        Default = {}
    })

    local function updateSelectedPets()
        getgenv().SELECTED_PETS = {}
        for name, pet in pairs(Pets) do
            if table.find(getgenv().SELECTED_RARITIES, tostring(pet.Rarity)) then
                table.insert(getgenv().SELECTED_PETS, name)
            end
        end
    end
    RaritiesDropdown:OnChanged(function(Value)
        getgenv().SELECTED_RARITIES = {}
        for i, v in Value do
            table.insert(getgenv().SELECTED_RARITIES, i)
        end
        updateSelectedPets()
        print(#getgenv().SELECTED_RARITIES, #getgenv().SELECTED_PETS)
    end)

    local webhookToggle = Tabs.Eggs:CreateToggle("webhookToggle", {Title = "Send Webhooks", Description = "", Default = false})

    local function convertToShorter(number, type)
        if type == "seconds" then
            local hours = math.floor(number / 3600)
            local minutes = math.floor((number % 3600) / 60)
            local seconds = number % 60
            return string.format("%dh %dm %ds", hours, minutes, seconds)
        elseif type == "hatches" then
            if number < 1000 then
                return tostring(number)
            elseif number < 1000000 then
                return string.format("%.2fk", number / 1000)
            else
                return string.format("%.2fm", number / 1000000)
            end
        elseif type == "bubbles" then
            if number < 1000000 then
                return tostring(number)
            elseif number < 1000000000 then
                return string.format("%.2fm", number / 1000000)
            else
                return string.format("%.2fb", number / 1000000000)
            end
        end
        return tostring(number)
    end

    local function getPlayerStats()
        local playerData = LocalDataService:Get() or {}
        local gems = playerData.Gems or 0
        local stats = playerData.Stats or {}
        local pets = playerData.Pets or {}

        return {
            playTime = convertToShorter(stats.Playtime or 0, "seconds"),
            hatches = convertToShorter(stats.Hatches or 0, "hatches"),
            bubbles = convertToShorter(stats.Bubbles or 0, "bubbles"),
            gems = convertToShorter(gems, "bubbles"),
        }
    end

    local function getImageThumbnail(assetId)
        local assetIdNumber = assetId:match("rbxassetid://(%d+)")
        if not assetIdNumber then
            warn("Error: Invalid assetId format")
            return nil
        end

        local url = "https://thumbnails.roblox.com/v1/assets?assetIds=" .. assetIdNumber .. "&size=420x420&format=png&isCircular=false"
        local request = http_request or request or HttpPost or syn.request
        if not request then
            warn("Error: HTTP request function not available")
            return nil
        end

        local success, response = pcall(function()
            return request({
                Url = url,
                Method = "GET",
                Headers = {["Content-Type"] = "application/json"}
            }).Body
        end)

        if success then
            local data = HttpService:JSONDecode(response)
            return data and data.data and data.data[1] and data.data[1].imageUrl or nil
        else
            warn("Error fetching thumbnail:", response)
        end

        return nil
    end

    local function sendWebhook(petData)
        if getgenv().WEBHOOK_URL == "" or getgenv().DISCORD_USER_ID == "" then
            warn("Error: WEBHOOK_URL or DISCORD_USER_ID is not set")
            return
        end

        local petInfo = Pets[petData.Name]
        if not petInfo then
            warn("Error: Pet info not found for", petData.Name)
            return
        end

        print("Preparing webhook for pet:", petData.Name)

        local player = Players.LocalPlayer
        local stats = getPlayerStats()
        local imageUrl = petInfo.Images and petInfo.Images.Normal and getImageThumbnail(petInfo.Images.Normal)

        local embed = {
            title = tostring(petInfo.Rarity).." Pet Hatched!",
            description = "**"..player.Name.."** hatched "..tostring(petInfo.Rarity).." pet!",
            color = getgenv().EMBED_COLOR,
            fields = {
                {name = "Pet Name 🏷️", value = petData.Name, inline = true},
                {name = "Rarity 🥚", value = petInfo.Rarity or "❌", inline = true},
                {name = "Shiny ✨", value = petData.Shiny and "✅" or "❌", inline = true},
                {name = "Mythic 🟣", value = petData.Mythic and "✅" or "❌", inline = true},
                {
                    name = "User Stats",
                    value = string.format(
                        "Gems 💎: %s\nHatches 🥚: %s\nBubbles 🫧: %s",
                        stats.gems, stats.hatches, stats.bubbles
                    ),
                    inline = false
                }
            },
            footer = {
                text = os.date("%Y-%m-%d %H:%M:%S")
            },
            thumbnail = imageUrl and {url = imageUrl} or nil
        }

        if petInfo.Stats then
            local statsText = ""
            for stat, value in pairs(petInfo.Stats) do
                if stat == "Bubbles" then
                    statsText = statsText .. stat .. " 🫧: " .. tostring(value) .. "\n"
                elseif stat == "Coins" then
                    statsText = statsText .. stat .. " 🪙: " .. tostring(value) .. "\n"
                elseif stat == "Gems" then
                    statsText = statsText .. stat .. " 💎: " .. tostring(value) .. "\n"
                end
            end
            table.insert(embed.fields, {name = "Pet Stats", value = statsText, inline = false})
        end

        local data = {
            content = "<@" .. getgenv().DISCORD_USER_ID .. ">",
            username = "Apel Hub Pet Notifier",
            avatar_url = "https://cdn.discordapp.com/avatars/414681006973386752/a_902d08360dfb7d7c2df774ab608848f6.gif?size=1024&width=640&height=640",
            embeds = {embed}
        }

        local request = http_request or request or HttpPost or syn.request
        if not request then
            warn("Error: HTTP request function not available")
            return
        end

        print("Sending webhook to:", getgenv().WEBHOOK_URL)
        local success, response = pcall(function()
            return request({
                Url = getgenv().WEBHOOK_URL,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = HttpService:JSONEncode(data)
            })
        end)

        if not success then
            warn("Error sending webhook:", response)
        else
            print("Webhook sent successfully")
        end
    end

    local function handleHatchEvent(eventType, data)
        if eventType == "HatchEgg" and typeof(data) == "table" and data.Pets then
            for i, pet in ipairs(data.Pets) do
                if typeof(pet) == "table" and pet.Pet and pet.Pet.Name and table.find(getgenv().SELECTED_PETS, tostring(pet.Pet.Name)) and pet.Deleted == false then
                    sendWebhook(pet.Pet)
                end
            end
        end
    end

    local connection = nil

    webhookToggle:OnChanged(function(State)
        print("webhookToggle changed, State:", State)
        if State then
            local remoteEvent = ReplicatedStorage.Shared:FindFirstChild("Framework") and 
                ReplicatedStorage.Shared.Framework.Network:FindFirstChild("Remote") and 
                ReplicatedStorage.Shared.Framework.Network.Remote:FindFirstChild("Event")

            if not remoteEvent then
                warn("Error: RemoteEvent not found")
                return
            end

            if not connection then
                connection = remoteEvent.OnClientEvent:Connect(handleHatchEvent)
                print("Webhook notifications enabled")
            end
        else
            if connection then
                connection:Disconnect()
                connection = nil
                print("Webhook notifications disabled")
            end
        end
    end)

    local PotionsToUse = nil
    local PotionsDropdown = Tabs.AutoUse:CreateDropdown("Potion List", {Title = "Select Potions For Auto Use", Description = "", Values = {"Lucky 1", "Lucky 2", "Lucky 3", "Lucky 4", "Lucky 5", "Lucky 6", "Speed 1", "Speed 2", "Speed 3", "Speed 4", "Speed 5", "Speed 6", "Mythic 1", "Mythic 2", "Mythic 3", "Mythic 4", "Mythic 5", "Mythic 6", "Coins 1", "Coins 2", "Coins 3", "Coins 4", "Coins 5", "Coins 6"}, Searchable = true, Multi = true, Default = {},})
    PotionsDropdown:OnChanged(function(Value)
        PotionsToUse = Value
    end)
    local function useGivenPotion(Potion, Level)
        local args = {
            [1] = "UsePotion",
            [2] = tostring(Potion),
            [3] = tonumber(Level)
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args)) 
    end
    local function AutoUseSelectedPotions()
        local LocalData = require(game:GetService("ReplicatedStorage").Client.Framework.Services.LocalData)
        local Data = LocalData:Get()
        local ActivePotion = Data.ActivePotions
        local PotionInventory = Data.Potions
        if not PotionsToUse or type(PotionsToUse) ~= "table" or not PotionInventory or type(PotionInventory) ~= "table" then
            warn("PotionsToUse is not a valid table:", PotionsToUse)
            return
        end
    
        for potionString, _ in pairs(PotionsToUse) do
            if type(potionString) ~= "string" then
                warn("Invalid potionString, expected string, got:", type(potionString), potionString)
                continue
            end
    
            local potionType, potionLevel = potionString:match("^(%a+)%s(%d+)$")
            if not potionType or not potionLevel then
                warn("Failed to parse potionString:", potionString)
                continue
            end
            potionLevel = tonumber(potionLevel)
    
            local shouldUsePotion = true
    
            if ActivePotion[potionType] and ActivePotion[potionType].Active then
                local activeLevel = ActivePotion[potionType].Active.Level
                if activeLevel and activeLevel == potionLevel then
                    shouldUsePotion = false
                end
            end

            if ActivePotion[potionType] and ActivePotion[potionType].Queue then
                for i, v in ActivePotion[potionType].Queue do
                    local queueLevel = ActivePotion[potionType].Queue[i].Level
                    if queueLevel and queueLevel == potionLevel then
                        shouldUsePotion = false
                    end
                end
            end

            local potionFound = false
            if shouldUsePotion then
                for _, potionData in ipairs(PotionInventory) do
                    if potionData.Name == potionType and potionData.Level == potionLevel and potionData.Amount > 0 then
                        potionFound = true
                        break
                    end
                end
            end
    
            if shouldUsePotion and potionFound then
                useGivenPotion(potionType, potionLevel)
                task.wait(0.01)
            end
        end
    end
    local AutoUseToggle = Tabs.AutoUse:CreateToggle("Auto Use Potions", {
        Title = "Enable Auto Use",
        Description = "Automatically use selected potions",
        Default = false
    })
    
    AutoUseToggle:OnChanged(function(value)
        getgenv().AutoUsePotions = value
        if value then
            while getgenv().AutoUsePotions == true do
                AutoUseSelectedPotions()
                task.wait()
            end
        end
    end)
    getgenv().SELECTED_RARITIES2 = nil
    getgenv().SELECTED_PETS2 = nil
    local RaritiesDropdown2 = Tabs.AutoDelete:CreateDropdown("RaritiesDropdown2", {
        Title = "Select Rarity For Auto Delete",
        Description = "I RECOMMEND USE THIS ONLY TO CLEAN UR INVENTORY, NOT TO USE IT INSTEAD OF GAME AUTODELETE",
        Values = {"Common", "Unique", "Rare", "Epic"},
        Searchable = true,
        Multi = true,
        Default = {}
    })
    local function updateSelectedPets2()
        getgenv().SELECTED_PETS2 = {}
        for name, pet in pairs(Pets) do
            if table.find(getgenv().SELECTED_RARITIES2, tostring(pet.Rarity)) then
                table.insert(getgenv().SELECTED_PETS2, name)
            end
        end
    end
    RaritiesDropdown2:OnChanged(function(Value)
        getgenv().SELECTED_RARITIES2 = {}
        for i, v in Value do
            table.insert(getgenv().SELECTED_RARITIES2, i)
        end
        updateSelectedPets2()
        print(#getgenv().SELECTED_RARITIES2, #getgenv().SELECTED_PETS2)
    end)

    local AutoDeleteToggle = Tabs.AutoDelete:CreateToggle("Auto Delete Pets", {
        Title = "Enable Auto Delete",
        Description = "Automatically Delete selected Rarities of pets",
        Default = false
    })
    local function deleteSelectedPets()
        local player = game:GetService("Players").LocalPlayer
        local petsFolder = player:FindFirstChild("Pets")
        if petsFolder then
            for i, v in petsFolder:GetChildren() do
                local namecheck = v:GetAttribute("Name")
                if table.find(getgenv().SELECTED_PETS2, namecheck) then
                    local args = {
                        [1] = "DeletePet",
                        [2] = tostring(v),
                        [3] = 1000,
                        [4] = false
                    }
                    
                    game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Framework"):WaitForChild("Network"):WaitForChild("Remote"):WaitForChild("Event"):FireServer(unpack(args))
                end
            end
        end
    end
    AutoDeleteToggle:OnChanged(function(value)
        getgenv().AutoDeleteToggle = value
        if value then
            while getgenv().AutoDeleteToggle == true do
                deleteSelectedPets()
                task.wait()
            end
        end
    end)
end




SaveManager:SetLibrary(Library)
InterfaceManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("Apel Hub")
SaveManager:SetFolder("Apel Hub/".."Bubble Gum")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)
SaveManager:LoadAutoloadConfig()

local Menu = game:GetService("CoreGui"):FindFirstChild("Menu")
if Menu then
    print("Найдено меню")
else
    local Menu = Instance.new("ScreenGui")
    Menu.Name = "Menu"
    local Frame = Instance.new("Frame")
    Frame.Name = "Menu Button"
    local ImageButton = Instance.new("ImageButton")
    local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
    local UIAspectRatioConstraint_2 = Instance.new("UIAspectRatioConstraint")

    -- Properties
    local coreGui = game:GetService("CoreGui")
    Menu.Parent = coreGui
    Menu.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    Frame.Parent = Menu
    Frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    Frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
    Frame.BorderSizePixel = 0
    Frame.Position = UDim2.new(0.167999998, 0, 0.230493277, 0)
    -- Уменьшаем размер на 25% (0.040533334 * 0.75, 0.0681614354 * 0.75)
    Frame.Size = UDim2.new(0.040533334 * 0.75, 0, 0.0681614354 * 0.75, 0)

    ImageButton.Parent = Frame
    ImageButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    ImageButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
    ImageButton.BorderSizePixel = 0
    ImageButton.Size = UDim2.new(1, 0, 1, 0)
    ImageButton.Image = "http://www.roblox.com/asset/?id=181239831"
    
    -- Функция кнопки
    ImageButton.MouseButton1Up:Connect(function()
        game:GetService("VirtualInputManager"):SendKeyEvent(true, "LeftControl", false, game)
    end)

    UIAspectRatioConstraint.Parent = ImageButton
    UIAspectRatioConstraint_2.Parent = Frame

    -- Логика перетаскивания
    local UserInputService = game:GetService("UserInputService")
    local dragging = false
    local dragStart = nil
    local startPos = nil

    local function updateInput(input)
        local delta = input.Position - dragStart
        Frame.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end

    ImageButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = Frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            updateInput(input)
        end
    end)
end
